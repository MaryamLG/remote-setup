!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!Python	nameref	/the original name for the tag/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!Python	I,namespace	/name referring a module defined in other file/
!_TAG_KIND_DESCRIPTION!Python	Y,unknown	/name referring a class\/variable\/function\/module defined in other module/
!_TAG_KIND_DESCRIPTION!Python	c,class	/classes/
!_TAG_KIND_DESCRIPTION!Python	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Python	i,module	/modules/
!_TAG_KIND_DESCRIPTION!Python	m,member	/class members/
!_TAG_KIND_DESCRIPTION!Python	v,variable	/variables/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!Python	0.1	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/vegard/Documents/qmodel/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	/ae6145e05/
!_TAG_ROLE_DESCRIPTION!Python!function	entryPoint	/specified as an entry point/
!_TAG_ROLE_DESCRIPTION!Python!module	entryPoint	/specified as a module of an entry point/
!_TAG_ROLE_DESCRIPTION!Python!module	imported	/imported modules/
!_TAG_ROLE_DESCRIPTION!Python!module	indirectlyImported	/module imported in alternative name/
!_TAG_ROLE_DESCRIPTION!Python!module	namespace	/namespace from where classes\/variables\/functions are imported/
!_TAG_ROLE_DESCRIPTION!Python!unknown	imported	/imported from the other module/
!_TAG_ROLE_DESCRIPTION!Python!unknown	indirectlyImported	/classes\/variables\/functions\/modules imported in alternative name/
B	./test/rabi_plot_vb.py	/^B = OB.tensor(SB)$/;"	v
Basis	./qmodel/qmodel.py	/^class Basis:$/;"	c
CouplingRabi	./test/rabi_plot_vb.py	/^CouplingRabi = SigmaZ*XOperator$/;"	v
DEGENERACY_ACCURACY	./qmodel/qmodel.py	/^DEGENERACY_ACCURACY = 1e-10$/;"	v
E	./qmodel/test.py	/^E = H.eig(hermitian = True)$/;"	v
E0	./test/comparison_vebjoern.py	/^E0 = np.zeros(len(l))$/;"	v
EnergyFunctional	./qmodel/dft.py	/^class EnergyFunctional:$/;"	c
G	./qmodel/dft.py	/^        def G(dens2):$/;"	f	member:EnergyFunctional.prox	file:
G	./qmodel/dft.py	/^        def G(pot):$/;"	f	member:EnergyFunctional.legendre_transform	file:
H	./qmodel/test.py	/^H = -b_lattice.sum(lambda qn: b_lattice.hop(next_site(qn), qn).add_adj()) + op1$/;"	v
H	./test/comparison_vebjoern.py	/^    H = Hamiltonian(t,l[i],v,j,n)$/;"	v
H	./test/comparison_vebjoern.py	/^H = Hamiltonian(t,l,v,j,n)$/;"	v
H	./test/rabi_plot_vb.py	/^H = H0_full + j*XOperator + v*SigmaZ # Hamiltonian, with external potential and current$/;"	v
H0_KS	./test/rabi_plot_vb.py	/^H0_KS = -t*SigmaX + oscillator.Kinetic(OB).extend(B) # Hamiltonian, just kinetic$/;"	v
H0_full	./test/rabi_plot_vb.py	/^H0_full = H0_KS + lam*CouplingRabi # Hamiltonian, with coupling$/;"	v
HERMITICITY_ACCURACY	./qmodel/qmodel.py	/^HERMITICITY_ACCURACY = 1e-6 # absolute tolerance in allclose, also use for diagonal matrix (cann/;"	v
Hamiltonian	./test/comparison_vebjoern.py	/^def Hamiltonian(t,l,v,j,n):$/;"	f
HamiltonianSp	./test/comparison_vebjoern.py	/^def HamiltonianSp(t,l,v,j,n):$/;"	f
IMAG_PART_ACCURACY	./qmodel/qmodel.py	/^IMAG_PART_ACCURACY = 1e-14$/;"	v
LatticeBasis	./qmodel/qmodel.py	/^class LatticeBasis(Basis): # always single-particle$/;"	c
M	./qmodel/test.py	/^M = 5$/;"	v
NumberBasis	./qmodel/qmodel.py	/^class NumberBasis(Basis): # for single state boson Fock space$/;"	c
OB	./test/rabi_plot_vb.py	/^OB = oscillator.Basis(oscillator_size)$/;"	v
Operator	./qmodel/qmodel.py	/^class Operator:$/;"	c
OperatorList	./qmodel/qmodel.py	/^class OperatorList: # list of operators$/;"	c
SB	./test/rabi_plot_vb.py	/^SB = spin.Basis()$/;"	v
SigmaX	./test/rabi_plot_vb.py	/^SigmaX = spin.SigmaX(SB).extend(B)$/;"	v
SigmaZ	./test/rabi_plot_vb.py	/^SigmaZ = spin.SigmaZ(SB).extend(B)$/;"	v
SpinBasis	./qmodel/qmodel.py	/^class SpinBasis(Basis): # always single-particle$/;"	c
T	./qmodel/qmodel.py	/^    def T(self) -> 'Operator': # transpose$/;"	m	class:Operator	typeref:typename:'Operator'
T	./qmodel/qmodel.py	/^    def T(self) -> 'OperatorList': # transpose$/;"	m	class:OperatorList	typeref:typename:'OperatorList'
VacuumBasis	./qmodel/qmodel.py	/^class VacuumBasis(Basis): # just C space$/;"	c
Vector	./qmodel/qmodel.py	/^class Vector:$/;"	c
XOperator	./test/rabi_plot_vb.py	/^XOperator = ((oscillator.Creator(OB) + oscillator.Annihilator(OB)) \/ sqrt(2)).extend(B)$/;"	v
__add__	./qmodel/qmodel.py	/^    def __add__(self, A):$/;"	m	class:Operator
__add__	./qmodel/qmodel.py	/^    def __add__(self, A):$/;"	m	class:OperatorList
__add__	./qmodel/qmodel.py	/^    def __add__(self, X):$/;"	m	class:Vector
__array_priority__	./qmodel/qmodel.py	/^    __array_priority__ = 10000 # use __rmul__ instead of NumPy's __mul__$/;"	v	class:OperatorList	file:
__getitem__	./qmodel/qmodel.py	/^    def __getitem__(self, index) -> Operator: # make subscriptable$/;"	m	class:OperatorList	typeref:typename:Operator
__init__	./qmodel/dft.py	/^    def __init__(self, H0: Operator, dens_operators: Union[Operator, OperatorList, list]):$/;"	m	class:EnergyFunctional
__init__	./qmodel/qmodel.py	/^    def __init__(self, basis: Basis):$/;"	m	class:Operator
__init__	./qmodel/qmodel.py	/^    def __init__(self, basis: Basis, col: list|np.ndarray = None): # can be initialized with col/;"	m	class:Vector
__init__	./qmodel/qmodel.py	/^    def __init__(self, basis: Basis, operators: list|None = None): # do NOT use empty list as de/;"	m	class:OperatorList
__init__	./qmodel/qmodel.py	/^    def __init__(self, max_num: int, qn_key: str = 'n'):$/;"	m	class:NumberBasis
__init__	./qmodel/qmodel.py	/^    def __init__(self, qn_key: str = 's'):$/;"	m	class:SpinBasis
__init__	./qmodel/qmodel.py	/^    def __init__(self, qn_key: str = 'vac'):$/;"	m	class:VacuumBasis
__init__	./qmodel/qmodel.py	/^    def __init__(self, qn_key: str = None, qn_range: Iterable[int|float]|None = None):$/;"	m	class:Basis
__init__	./qmodel/qmodel.py	/^    def __init__(self, vertex_num: int, qn_key: str = 'i'):$/;"	m	class:LatticeBasis
__len__	./qmodel/qmodel.py	/^    def __len__(self):$/;"	m	class:Operator
__len__	./qmodel/qmodel.py	/^    def __len__(self):$/;"	m	class:OperatorList
__mul__	./qmodel/qmodel.py	/^    def __mul__(self, A):$/;"	m	class:Operator
__mul__	./qmodel/qmodel.py	/^    def __mul__(self, A):$/;"	m	class:OperatorList
__mul__	./qmodel/qmodel.py	/^    def __mul__(self, a):$/;"	m	class:Vector
__neg__	./qmodel/qmodel.py	/^    def __neg__(self):$/;"	m	class:Operator
__neg__	./qmodel/qmodel.py	/^    def __neg__(self):$/;"	m	class:OperatorList
__neg__	./qmodel/qmodel.py	/^    def __neg__(self):$/;"	m	class:Vector
__pow__	./qmodel/qmodel.py	/^    def __pow__(self, a):$/;"	m	class:Operator
__radd__	./qmodel/qmodel.py	/^    def __radd__(self, A):$/;"	m	class:Operator
__rmul__	./qmodel/qmodel.py	/^    def __rmul__(self, A):$/;"	m	class:Operator
__rmul__	./qmodel/qmodel.py	/^    def __rmul__(self, A):$/;"	m	class:OperatorList
__rmul__	./qmodel/qmodel.py	/^    def __rmul__(self, a):$/;"	m	class:Vector
__rsub__	./qmodel/qmodel.py	/^    def __rsub__(self, A):$/;"	m	class:Operator
__str__	./qmodel/qmodel.py	/^    def __str__(self) -> str:$/;"	m	class:Basis	typeref:typename:str
__str__	./qmodel/qmodel.py	/^    def __str__(self) -> str:$/;"	m	class:Vector	typeref:typename:str
__str__	./qmodel/qmodel.py	/^    def __str__(self):$/;"	m	class:Operator
__str__	./qmodel/qmodel.py	/^    def __str__(self):$/;"	m	class:OperatorList
__sub__	./qmodel/qmodel.py	/^    def __sub__(self, A):$/;"	m	class:Operator
__sub__	./qmodel/qmodel.py	/^    def __sub__(self, X):$/;"	m	class:Vector
__truediv__	./qmodel/qmodel.py	/^    def __truediv__(self, a):$/;"	m	class:Operator
__truediv__	./qmodel/qmodel.py	/^    def __truediv__(self, a):$/;"	m	class:OperatorList
__truediv__	./qmodel/qmodel.py	/^    def __truediv__(self, a):$/;"	m	class:Vector
_find_qn	./qmodel/qmodel.py	/^    def _find_qn(self, qn: dict|str) -> list:$/;"	m	class:Basis	typeref:typename:list
_find_qn_el	./qmodel/qmodel.py	/^        def _find_qn_el(qn: dict|str, el: dict|tuple, pos_list: list|None = None, permutation_si/;"	f	member:Basis._find_qn	file:
_remove_qn_el	./qmodel/qmodel.py	/^        def _remove_qn_el(el: dict|tuple, pos_list: list, pos_current: list|None = None, symmetr/;"	f	member:Basis.hop	file:
_test_basis	./qmodel/qmodel.py	/^    def _test_basis(self, A): # private method for basis comparison \/ use name as 'forward refe/;"	m	class:Operator
_test_basis	./qmodel/qmodel.py	/^    def _test_basis(self, X): # private method for basis comparison \/ use name as 'forward refe/;"	m	class:Vector
acomm	./qmodel/qmodel.py	/^    def acomm(self, A: 'Operator') -> 'Operator':$/;"	m	class:Operator	typeref:typename:'Operator'
add_adj	./qmodel/qmodel.py	/^    def add_adj(self) -> 'Operator': # add adjoint (h.c.) to operator itself$/;"	m	class:Operator	typeref:typename:'Operator'
adj	./qmodel/qmodel.py	/^    def adj(self) -> 'Operator': # adjoint$/;"	m	class:Operator	typeref:typename:'Operator'
adj	./qmodel/qmodel.py	/^    def adj(self) -> 'OperatorList': # adjoint$/;"	m	class:OperatorList	typeref:typename:'OperatorList'
annihilator	./qmodel/qmodel.py	/^    def annihilator(self) -> 'Operator':$/;"	m	class:NumberBasis	typeref:typename:'Operator'
append	./qmodel/qmodel.py	/^    def append(self, operators: Operator|list):$/;"	m	class:OperatorList
ax	./test/rabi_plot_vb.py	/^fig, ax = plot_functionals()$/;"	v
ax0	./test/comparison_vebjoern.py	/^fig0, ax0 = plt.subplots(2, figsize=(9,5),sharex=True, sharey=True)$/;"	v
ax01	./test/comparison_vebjoern.py	/^fig01, ax01 = plt.subplots(1, figsize=(9,5))$/;"	v
ax02	./test/comparison_vebjoern.py	/^fig02, ax02 = plt.subplots(1,2, figsize=(9,5),sharex=False, sharey=True)$/;"	v
ax03	./test/comparison_vebjoern.py	/^fig03, ax03 = plt.subplots(2, figsize=(9,5),sharex=True,sharey=False)$/;"	v
b	./qmodel/test.py	/^b = b1.ntensor(2)$/;"	v
b	./qmodel/test.py	/^b = b1.tensor(b2)$/;"	v
b1	./qmodel/test.py	/^b1 = Basis('key1', range(3))$/;"	v
b2	./qmodel/test.py	/^b2 = Basis('key2', range(3))$/;"	v
b_lattice	./qmodel/test.py	/^b_lattice = LatticeBasis(M)$/;"	v
comm	./qmodel/qmodel.py	/^    def comm(self, A: 'Operator') -> 'Operator':$/;"	m	class:Operator	typeref:typename:'Operator'
conj	./qmodel/qmodel.py	/^    def conj(self) -> 'Operator': # conjugate$/;"	m	class:Operator	typeref:typename:'Operator'
conj	./qmodel/qmodel.py	/^    def conj(self) -> 'OperatorList': # conjugate$/;"	m	class:OperatorList	typeref:typename:'OperatorList'
copy	./qmodel/qmodel.py	/^    def copy(self) -> 'Operator':$/;"	m	class:Operator	typeref:typename:'Operator'
copy	./qmodel/qmodel.py	/^    def copy(self) -> 'OperatorList':$/;"	m	class:OperatorList	typeref:typename:'OperatorList'
copy	./qmodel/qmodel.py	/^    def copy(self) -> 'Vector':$/;"	m	class:Vector	typeref:typename:'Vector'
creator	./qmodel/qmodel.py	/^    def creator(self) -> 'Operator':$/;"	m	class:NumberBasis	typeref:typename:'Operator'
diag	./qmodel/qmodel.py	/^    def diag(self) -> dict:$/;"	m	class:Operator	typeref:typename:dict
diag	./qmodel/qmodel.py	/^    def diag(self, qn_key: str|None = None) -> 'Operator': # diagonal qn operator$/;"	m	class:Basis	typeref:typename:'Operator'
diag	./qmodel/qmodel.py	/^    def diag(self, trials: int = 5) -> dict:$/;"	m	class:OperatorList	typeref:typename:dict
dx_operator	./qmodel/qmodel.py	/^    def dx_operator(self) -> 'Operator':$/;"	m	class:NumberBasis	typeref:typename:'Operator'
eig	./qmodel/qmodel.py	/^    def eig(self, hermitian: bool = False) -> dict:$/;"	m	class:Operator	typeref:typename:dict
eig	./test/comparison_vebjoern.py	/^    eigvals, eig = np.linalg.eigh(H)$/;"	v
eig	./test/comparison_vebjoern.py	/^eigvals, eig = np.linalg.eigh(H)$/;"	v
eigvals	./test/comparison_vebjoern.py	/^    eigvals, eig = np.linalg.eigh(H)$/;"	v
eigvals	./test/comparison_vebjoern.py	/^eigvals, eig = np.linalg.eigh(H)$/;"	v
eps	./qmodel/test.py	/^eps = 1e-15 # accuracy for tests$/;"	v
expval	./qmodel/qmodel.py	/^    def expval(self, vec: Vector, check_real = False, transform_real = False) -> float|complex:$/;"	m	class:OperatorList	typeref:typename:float|complex
expval	./qmodel/qmodel.py	/^    def expval(self, vec: Vector, check_real: bool = False, transform_real: bool = False) -> flo/;"	m	class:Operator	typeref:typename:float|complex
extend	./qmodel/qmodel.py	/^    def extend(self, ext_basis: Basis) -> 'Operator':$/;"	m	class:Operator	typeref:typename:'Operator'
extend	./qmodel/qmodel.py	/^    def extend(self, ext_basis: Basis) -> 'OperatorList':$/;"	m	class:OperatorList	typeref:typename:'OperatorList'
fig	./test/rabi_plot_vb.py	/^fig, ax = plot_functionals()$/;"	v
fig0	./test/comparison_vebjoern.py	/^fig0, ax0 = plt.subplots(2, figsize=(9,5),sharex=True, sharey=True)$/;"	v
fig01	./test/comparison_vebjoern.py	/^fig01, ax01 = plt.subplots(1, figsize=(9,5))$/;"	v
fig02	./test/comparison_vebjoern.py	/^fig02, ax02 = plt.subplots(1,2, figsize=(9,5),sharex=False, sharey=True)$/;"	v
fig03	./test/comparison_vebjoern.py	/^fig03, ax03 = plt.subplots(2, figsize=(9,5),sharex=True,sharey=False)$/;"	v
graph_laplacian	./qmodel/qmodel.py	/^    def graph_laplacian(self, graph_edges: set, qn_key: str = 'i', hopping: float = 1, include_d/;"	m	class:LatticeBasis	typeref:typename:'Operator'
graph_pot	./qmodel/qmodel.py	/^    def graph_pot(self, pot: dict|list|np.ndarray, qn_key: str = 'i') -> 'Operator':$/;"	m	class:LatticeBasis	typeref:typename:'Operator'
gs_energy	./qmodel/test.py	/^gs_energy = E['eigenvalues'][0]$/;"	v
gs_vector	./qmodel/test.py	/^gs_vector = E['eigenvectors'][0]$/;"	v
hop	./qmodel/qmodel.py	/^    def hop(self, qn1: dict, qn2: dict|None = None) -> 'Operator': # Hilbert one-body operator \//;"	m	class:Basis	typeref:typename:'Operator'
id	./qmodel/qmodel.py	/^    def id(self) -> 'Operator': # identity operator$/;"	m	class:Basis	typeref:typename:'Operator'
inner	./qmodel/qmodel.py	/^    def inner(self, X) -> complex:$/;"	m	class:Vector	typeref:typename:complex
j	./test/comparison_vebjoern.py	/^j = 0  $/;"	v
j	./test/comparison_vebjoern.py	/^j=0$/;"	v
j	./test/rabi_plot_vb.py	/^j = 0$/;"	v
l	./test/comparison_vebjoern.py	/^l = np.linspace(0,10,1001)$/;"	v
l	./test/comparison_vebjoern.py	/^l=5$/;"	v
lam	./test/rabi_plot_vb.py	/^lam = 1$/;"	v
legendre_transform	./qmodel/dft.py	/^    def legendre_transform(self, dens: Union[float, list[float]],$/;"	m	class:EnergyFunctional
moreau_envelope	./qmodel/dft.py	/^def moreau_envelope(xspan, func, epsMY: float):$/;"	f
n	./test/comparison_vebjoern.py	/^n=50 $/;"	v
next_site	./qmodel/test.py	/^next_site = lambda qn: dict(qn, i=qn['i']%M+1)$/;"	f
norm	./qmodel/qmodel.py	/^    def norm(self) -> float: # 2-norm of operator list$/;"	m	class:OperatorList	typeref:typename:float
norm	./qmodel/qmodel.py	/^    def norm(self) -> float: # 2-norm of operator$/;"	m	class:Operator	typeref:typename:float
norm	./qmodel/qmodel.py	/^    def norm(self) -> float: # 2-norm of vector$/;"	m	class:Vector	typeref:typename:float
np	./qmodel/dft.py	/^import numpy as np$/;"	I	nameref:module:numpy
np	./qmodel/qmodel.py	/^import numpy as np$/;"	I	nameref:module:numpy
np	./test/comparison_vebjoern.py	/^import numpy as np$/;"	I	nameref:module:numpy
np	./test/rabi_plot_vb.py	/^import numpy as np$/;"	I	nameref:module:numpy
np_map	./qmodel/dft.py	/^def np_map(func, xiter):$/;"	f
ntensor	./qmodel/qmodel.py	/^    def ntensor(self, n: int, symmetry: str = 'x') -> 'Basis':$/;"	m	class:Basis	typeref:typename:'Basis'
numdelta	./qmodel/test.py	/^def numdelta(n1, n2):$/;"	f
op1	./qmodel/test.py	/^op1 = b.diag('key1')$/;"	v
op1	./qmodel/test.py	/^op1 = b1.diag().extend(b)$/;"	v
op1	./qmodel/test.py	/^op1 = b_lattice.diag()$/;"	v
op2	./qmodel/test.py	/^op2 = b1.diag().extend(b)$/;"	v
op2	./qmodel/test.py	/^op2 = b1.diag().tensor(b1.id(), b) + b1.id().tensor(b1.diag(), b)$/;"	v
op2	./qmodel/test.py	/^op2 = b_lattice.sum(lambda qn: qn['i']*b_lattice.hop(qn))$/;"	v
op3	./qmodel/test.py	/^op3 = b.diag() # gives same operator$/;"	v
opdelta	./qmodel/test.py	/^def opdelta(op1, op2):$/;"	f
oscillator_size	./test/rabi_plot_vb.py	/^oscillator_size = 10$/;"	v
plot_functionals	./test/rabi_plot_vb.py	/^def plot_functionals():$/;"	f
plt	./test/comparison_vebjoern.py	/^import matplotlib.pyplot as plt$/;"	I	nameref:module:matplotlib.pyplot
plt	./test/rabi_plot_vb.py	/^import matplotlib.pyplot as plt$/;"	I	nameref:module:matplotlib.pyplot
prob	./qmodel/qmodel.py	/^    def prob(self) -> np.ndarray:$/;"	m	class:Vector	typeref:typename:np.ndarray
proj_minus	./qmodel/qmodel.py	/^    def proj_minus(self) -> 'Operator':$/;"	m	class:SpinBasis	typeref:typename:'Operator'
proj_plus	./qmodel/qmodel.py	/^    def proj_plus(self) -> 'Operator':$/;"	m	class:SpinBasis	typeref:typename:'Operator'
prox	./qmodel/dft.py	/^    def prox(self, dens: Union[float, list], epsMY: float):$/;"	m	class:EnergyFunctional
psi0	./test/comparison_vebjoern.py	/^psi0 = np.zeros((2*n,len(l)))$/;"	v
sigma	./test/comparison_vebjoern.py	/^def sigma(psi):$/;"	f
sigma_minus	./qmodel/qmodel.py	/^    def sigma_minus(self) -> 'Operator':$/;"	m	class:SpinBasis	typeref:typename:'Operator'
sigma_plus	./qmodel/qmodel.py	/^    def sigma_plus(self) -> 'Operator':$/;"	m	class:SpinBasis	typeref:typename:'Operator'
sigma_vec	./qmodel/qmodel.py	/^    def sigma_vec(self) -> 'OperatorList':$/;"	m	class:SpinBasis	typeref:typename:'OperatorList'
sigma_x	./qmodel/qmodel.py	/^    def sigma_x(self) -> 'Operator':$/;"	m	class:SpinBasis	typeref:typename:'Operator'
sigma_y	./qmodel/qmodel.py	/^    def sigma_y(self) -> 'Operator':$/;"	m	class:SpinBasis	typeref:typename:'Operator'
sigma_z	./qmodel/qmodel.py	/^    def sigma_z(self) -> 'Operator':$/;"	m	class:SpinBasis	typeref:typename:'Operator'
sns	./test/rabi_plot_vb.py	/^import seaborn as sns$/;"	I	nameref:module:seaborn
solve	./qmodel/dft.py	/^    def solve(self, pot: Union[float, list]):$/;"	m	class:EnergyFunctional
sp	./test/comparison_vebjoern.py	/^import sympy as sp$/;"	I	nameref:module:sympy
sum	./qmodel/qmodel.py	/^    def sum(self) -> Operator: # sum and return Operator$/;"	m	class:OperatorList	typeref:typename:Operator
sum	./qmodel/qmodel.py	/^    def sum(self, func: Callable):$/;"	m	class:Basis
t	./test/comparison_vebjoern.py	/^t = 1$/;"	v
t	./test/comparison_vebjoern.py	/^t=1$/;"	v
t	./test/rabi_plot_vb.py	/^t = 1$/;"	v
tensor	./qmodel/qmodel.py	/^    def tensor(self, A: 'Operator', tensor_basis: Basis = None) -> 'OperatorList': # return new /;"	m	class:OperatorList	typeref:typename:'OperatorList'
tensor	./qmodel/qmodel.py	/^    def tensor(self, A: Union['Operator', 'OperatorList'], tensor_basis: Basis = None) -> Union[/;"	m	class:Operator	typeref:typename:Union['Operator','OperatorList']
tensor	./qmodel/qmodel.py	/^    def tensor(self, basis: 'Basis') -> 'Basis':$/;"	m	class:Basis	typeref:typename:'Basis'
test_hermiticity	./qmodel/qmodel.py	/^    def test_hermiticity(self):$/;"	m	class:Operator
timer	./qmodel/timer.py	/^def timer(func):$/;"	f
trace	./qmodel/qmodel.py	/^    def trace(self, subbasis: Basis) -> np.ndarray:$/;"	m	class:Vector	typeref:typename:np.ndarray
v	./test/comparison_vebjoern.py	/^v = 0$/;"	v
v	./test/comparison_vebjoern.py	/^v=0$/;"	v
v	./test/rabi_plot_vb.py	/^v = 0.02$/;"	v
wedge	./qmodel/qmodel.py	/^    def wedge(self, n: int) -> 'Basis':$/;"	m	class:Basis	typeref:typename:'Basis'
wrapper	./qmodel/timer.py	/^    def wrapper(*args, **kwargs):$/;"	f	function:timer	file:
x	./test/comparison_vebjoern.py	/^def x(psi):$/;"	f
x_operator	./qmodel/qmodel.py	/^    def x_operator(self) -> 'Operator':$/;"	m	class:NumberBasis	typeref:typename:'Operator'
